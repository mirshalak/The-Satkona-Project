The Skeleton Key, or 8 core functions.  This may be abbreviated to "SK8."

001:push  (Transmit data to stack memory)
002:store (Transmit data to register/heap memory)
003:pop (Receive data from stack memory)   
004:load (Receive data from register/heap memory)
005:define-word (This is equivalent to the word compilation pair in FORTH)
006:execute-word 
007:add  
008:subtract

sk8-purpose+01("To permit total reconstruction from the minimal viable initial
state.  Viable is defined by the ability to execute secondary loops, which Brainf*** 
in particular was incapable of.").

sk8-purpose+02("To create a semantic framework and execution model, which
allows the reliable generation of code by artificial intelligence.  It has been
observed that language models produce much more elegant and reliable code, when
the parameter stack is used as the central data structure.").

two-stacks("Parameter stack and return stack.").

parameter-stack-contents("Word parameter data.").

return-stack-contents("Addresses of 1 or more words to be executed.").

heap-contents("Definitions and contents of words.").

parameter-stack("Preferred mechanism for all general-purpose computation.").

store-and-load-words("Exist solely to support the operation of define-word and execute-word.").

store-and-load-words("Not to be used otherwise.").

word-addresses("Words are to have Hexgate addresses, following the above 8.").

no-explicit-branching("Hexgate addressing gives everything within a given
physical or virtual environment an address, and the address of every object, is
also the address of the relevant word for interacting with it within the
system.  Branching can be achieved by assigning a relevant address to every
point within a system.  For a thermostat as one example, every word numbered
between 1 and 100 within the current dictionary, could represent the
corresponding temperature.").

core-invariance("The core SK8 instruction set (001â€“008) must remain immutable
and distinct from all higher-level or API-specific word dictionaries. This
ensures minimal survivable execution and prevents dependency pollution.").

word-tokens("Words consist of individual tokens, which begin and end with the space character: ASCII decimal code 32.")
word-start("define-word")
word-second-token("word name")
word-end("000.").
word-example("define-word dup heap-variable store heap-variable load push 000")

```javascript
// skeleton_key_vm.js

class SK8VM {
  constructor() {
    this.parameterStack = [];
    this.returnStack = [];
    this.heap = new Map(); // wordAddress (as string) => array of opcodes
    this.registers = {};   // not used directly, preserved for load/store
  }

  executeNextWord() {
    if (this.returnStack.length === 0) {
      throw new Error("Return stack is empty; no word to execute.");
    }

    const addr = this.returnStack.pop();
    const word = this.heap.get(String(addr));

    if (!word) {
      throw new Error(`No word defined at address ${addr}`);
    }

    for (const opcode of word) {
      this.executeInstruction(opcode);
    }
  }

  executeInstruction(opcode) {
    const instr = opcode[0];
    const arg = opcode[1];

    switch (instr) {
      case 1: // push
        this.parameterStack.push(arg);
        break;
      case 2: // store
        this.registers[arg] = this.parameterStack.pop();
        break;
      case 3: // pop
        this.parameterStack.pop();
        break;
      case 4: // load
        this.parameterStack.push(this.registers[arg]);
        break;
      case 5: // define-word
        this.defineWord(arg);
        break;
      case 6: // execute-word (pull next address from return stack)
        this.executeNextWord();
        break;
      case 7: // add
        const b = this.parameterStack.pop();
        const a = this.parameterStack.pop();
        this.parameterStack.push(a + b);
        break;
      case 8: // subtract
        const d = this.parameterStack.pop();
        const c = this.parameterStack.pop();
        this.parameterStack.push(c - d);
        break;
      default:
        throw new Error(`Unknown opcode: ${instr}`);
    }
  }

  defineWord(wordDefinition) {
    // wordDefinition: { address: number|string, body: [ [opcode, arg], ... ] }
    if (!wordDefinition || typeof wordDefinition.address === "undefined" || !Array.isArray(wordDefinition.body)) {
      throw new Error("Invalid word definition format.");
    }

    const addr = String(wordDefinition.address);
    this.heap.set(addr, wordDefinition.body);
  }

  // Helper to load a word address into return stack
  call(address) {
    this.returnStack.push(String(address));
  }

  dumpStacks() {
    return {
      parameterStack: [...this.parameterStack],
      returnStack: [...this.returnStack],
    };
  }
}

export default SK8VM;
```

