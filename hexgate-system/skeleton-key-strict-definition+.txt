12345678901234567890123456789012345678901234567890123456789012345678901234567890

The Skeleton Key; 7 core functions.  This may be abbreviated to "SK7."

001(+, "Addition").
002(-, "Subtraction").
003(., "Print the top of the stack").   
004(drop, "Pop the top of the parameter stack, without printing").
005(swap, ("Swap the top two cells from the parameter stack").
006(dup, "Duplicate the top of the parameter stack"). 
007(:, "Compile new words from currently existing words").

skeleton-key-purpose("To allow syntactically consistent functionality, in any 
programming language to which it is translated.").  

not-self-hosting("SK7 is neither inherently self-hosting, nor Turing complete.  
Looping and branching are performed by the host language.  SK7's purpose is not 
to be a Turing machine itself, but to create a consistent interface for others.  
Primitives and intermediates are constructed as words for the vm, and then flow 
control (looping, branching) is performed by the host language.").

two-stacks("Parameter stack and return stack.").
parameter-stack-contents("Word parameter data.").
return-stack-contents("Addresses of 1 or more words to be executed.").
parameter-stack("Preferred mechanism for all general-purpose computation.").

core-invariance("The core SK7 instruction set (001–007) must remain immutable
and distinct from all higher-level or API-specific word dictionaries. This
ensures minimal survivable execution and prevents dependency pollution.").

word-tokens("Words consist of individual tokens, which begin and end with the space 
character: ASCII decimal code 32.")
word-start(":")
word-second-token("word name")
word-third-to-last-token("word body")
word-end(";")

// sk7.js

export class SK7 {
  constructor() {
    this.stack = [];
    this.returnStack = []; 
    this.dictionary = {};

    // Core Words
    this.define('+', () => {
      const b = this.stack.pop();
      const a = this.stack.pop();
      this.stack.push(a + b);
    });

    this.define('-', () => {
      const b = this.stack.pop();
      const a = this.stack.pop();
      this.stack.push(a - b);
    });

    this.define('.', () => {
    const value = this.stack.pop();

    const p = Deno.run({
    cmd: ["echo", String(value)],
    stdout: "inherit",
    stderr: "inherit",
      });
    });

    // ── New core word: drop ( x -- )
    this.define('drop', () => {
      // You can add an underflow check if you want:
      if (this.stack.length < 1) throw new Error("Stack underflow in drop");
      this.stack.pop();
    });

    // ── New core word: swap ( a b -- b a )
    this.define('swap', () => {
      // Optional safety:
      if (this.stack.length < 2) throw new Error("Stack underflow in swap");
      const b = this.stack.pop();
      const a = this.stack.pop();
      this.stack.push(b);
      this.stack.push(a);
    });

    this.define('dup', () => {
      const a = this.stack[this.stack.length - 1];
      this.stack.push(a);
    });

    this.define(':', (tokens, i) => {
      const name = tokens[++i];
      const body = [];

      while (++i < tokens.length && tokens[i] !== ';') {
        body.push(tokens[i]);
      }

      this.dictionary[name] = () => this.execute(body);
      return i; // jump to after ;
    });
  }

  define(word, fn) {
    this.dictionary[word] = fn;
  }

execute(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];

    if (token.startsWith('"')) {
      // Start of a string literal
      let str = token.slice(1); // remove opening quote
      while (!tokens[i].endsWith('"') && i + 1 < tokens.length) {
        i++;
        str += ' ' + tokens[i];
      }
      // Remove closing quote
      if (tokens[i].endsWith('"')) {
        str = str.slice(0, -1);
      }
      this.stack.push(str);
    }

    else if (!isNaN(token)) {
      this.stack.push(parseFloat(token));
    }

    else if (this.dictionary[token]) {
      const word = this.dictionary[token];
      const result = word(tokens, i);
      if (typeof result === 'number') i = result;
    }

    else {
      throw new Error(`Unknown word: ${token}`);
    }
  }
}

  run(code) {
    const tokens = code.trim().split(/\s+/);
    this.execute(tokens);
  }
}

// Usage Example

const vm = new SK7();

vm.run(': inc 1 + ;');
vm.run('1 dup inc dup inc dup inc . . . .');
vm.run(': payload "hello" . ;');

vm.run('5 5 + ');
var = this.stack.pop();
if (var === 10) {
vm.run('payload');
}
