12345678901234567890123456789012345678901234567890123456789012345678901234567890

The Skeleton Key, or 8 core functions.  This may be abbreviated to "SK8."

001(+, "Addition").
002(-, "Subtraction").
003(., "Print the top of the stack").   
004(r>, "Push the top of the parameter stack, to the top of the return stack").
005(r<, (Push the top of the return stack, to the top of the parameter stack").
006(dup, "Duplicate the top of the parameter stack"). 
007(r@, "Print cell count of return stack").
008(:, "Compile new words from currently existing words").

sk8-purpose("To create a semantic framework and execution model, which
allows the reliable generation of code by artificial intelligence.  It has been
observed that language models produce much more elegant and reliable code, when
the parameter stack is used as the central data structure.").

two-stacks("Parameter stack and return stack.").
parameter-stack-contents("Word parameter data.").
return-stack-contents("Addresses of 1 or more words to be executed.").
heap-contents("Definitions and contents of words.").
parameter-stack("Preferred mechanism for all general-purpose computation.").
store-and-load-words("Exist solely to support the operation of define-word and execute-word.").
store-and-load-words("Not to be used otherwise.").

word-addresses("Words are to have Hexgate addresses, following the above 8.").

loop-branch("Looping and branching are to be achieved via define-word,
execute-word, and the return stack.").

core-invariance("The core SK8 instruction set (001â€“008) must remain immutable
and distinct from all higher-level or API-specific word dictionaries. This
ensures minimal survivable execution and prevents dependency pollution.").

word-tokens("Words consist of individual tokens, which begin and end with the space character: ASCII decimal code 32.")
word-start(":")
word-second-token("word name")
word-third-to-last-token("word body")
word-end(";")

// sk8_core.js

export class SK8 {
  constructor() {
    this.stack = [];
    this.returnStack = []; 
    this.dictionary = {};

    // Core Words
    this.define('+', () => {
      const b = this.stack.pop();
      const a = this.stack.pop();
      this.stack.push(a + b);
    });

    this.define('-', () => {
      const b = this.stack.pop();
      const a = this.stack.pop();
      this.stack.push(a - b);
    });

    this.define('.', () => {
    const value = this.stack.pop();

    const p = Deno.run({
    cmd: ["echo", String(value)],
    stdout: "inherit",
    stderr: "inherit",
      });
    });

    this.define('>r', () => {
        this.returnStack.push(this.stack.pop());
});

    this.define('r>', () => {
        this.stack.push(this.returnStack.pop());
});

    this.define('r@', () => {
        this.stack.push(this.returnStack[this.returnStack.length - 1]);
}); 

    this.define('dup', () => {
      const a = this.stack[this.stack.length - 1];
      this.stack.push(a);
    });

    this.define(':', (tokens, i) => {
      const name = tokens[++i];
      const body = [];

      while (++i < tokens.length && tokens[i] !== ';') {
        body.push(tokens[i]);
      }

      this.dictionary[name] = () => this.execute(body);
      return i; // jump to after ;
    });
  }

  define(word, fn) {
    this.dictionary[word] = fn;
  }

execute(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];

    if (token.startsWith('"')) {
      // Start of a string literal
      let str = token.slice(1); // remove opening quote
      while (!tokens[i].endsWith('"') && i + 1 < tokens.length) {
        i++;
        str += ' ' + tokens[i];
      }
      // Remove closing quote
      if (tokens[i].endsWith('"')) {
        str = str.slice(0, -1);
      }
      this.stack.push(str);
    }

    else if (!isNaN(token)) {
      this.stack.push(parseFloat(token));
    }

    else if (this.dictionary[token]) {
      const word = this.dictionary[token];
      const result = word(tokens, i);
      if (typeof result === 'number') i = result;
    }

    else {
      throw new Error(`Unknown word: ${token}`);
    }
  }
}

  run(code) {
    const tokens = code.trim().split(/\s+/);
    this.execute(tokens);
  }
}

// Usage Example

const vm = new SK8();

forth.run(': inc 1 + ;');
forth.run('1 dup inc dup inc dup inc popall');
